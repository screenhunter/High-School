import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.htmlcleaner.CleanerProperties;
import org.htmlcleaner.HtmlCleaner;
import org.htmlcleaner.SimpleHtmlSerializer;
import org.htmlcleaner.TagNode;

public class VulnerabilityLister {

	private static final String TBL_START = "<table class=\"searchresults sortable\" id=\"vulnslisttable\">";
	private static final String TBL_END = "</table>";

	private static final String ROW_START_1 = "<tr class=\"srrowns\">";
	private static final String ROW_START_2 = "<tr>";
	private static final String ROW_END = "</tr>";

	private static final String COL_START = "<td";
	private static final String COL_END = "</td";

	private static final String HREF_START = "href=\"";
	private static final String XML_START = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?> ";

	private static final String STYLE_START = "<b style=\"color:red\">";
	private static final String STYLE_END = "</b>";

	private static String files;

	private static HashSet<String> hs = new HashSet<String>();

	private static String outputDir = "D:\\temp\\";

	private static int pos = 0;

	private static String TD_START = "<\\s*t\\s*d\\s*[^>]*>";
	private static String TD_END = "<\\s*/\\s*t\\s*d\\s*[^>]*>";
	private static Pattern p = Pattern.compile(TD_START);
	private static Pattern p2 = Pattern.compile(TD_END);

	public static ArrayList<String> main(String args)
			throws InterruptedException {

		files = args;

		// Create the URL obect that points
		// at the default file index.html
		int fcnt = 0;
		List<String> failedFiles = new ArrayList<String>();
		List<String> failedHrefs = new ArrayList<String>();
		String dir = getFileDirName(files);
		// System.out.println(dir + "  " + file);
		pos = 0;
		return downloadRecurse(files, fcnt++, failedFiles, failedHrefs, dir);

	}

	private static ArrayList<String> downloadRecurse(String file, int fcnt,
			List<String> failedFiles, List<String> failedHrefs, String dir)
			throws InterruptedException {
		String ban = "" + ++fcnt + " of " + files.length();
		String str = null;
		try {
			str = readFile(file, ban);
		} catch (MalformedURLException e) {
			System.out.println("Please check the URL:" + e.toString());
			failedFiles.add(file);
			return null;
			// e.printStackTrace();
		} catch (IOException e1) {
			System.out.println("Can't read  from the Internet: "
					+ e1.toString());
			// e1.printStackTrace();
			failedFiles.add(file);
			// System.out.println(file);
			return null;
		}

//		 System.out.println("----> reading " + file);
//		 System.out.println("----> reading " + str);
		int start = str.indexOf(TBL_START);
		int end = str.indexOf(TBL_END, start);
//		System.out.println(start +  "  " + end);
//		System.out.println(str);
		str = str.substring(start, end + TBL_END.length());
		// System.out.println(str);
		// processHtml(str);
		HtmlCleaner cleaner = new HtmlCleaner();

		// take default cleaner properties
		CleanerProperties props = cleaner.getProperties();

		SimpleHtmlSerializer htmlSerializer = new SimpleHtmlSerializer(props);
		// customize cleaner's behaviour with property setters
		// props.setXXX(...);

		// Clean HTML taken from simple string, file, URL, input stream,
		// input source or reader. Result is root node of created
		// tree-like structure. Single cleaner instance may be safely used
		// multiple times.
		TagNode node = cleaner.clean(str);
		// str = cleaner.getInnerHtml(node);
		// System.out.println(str);
		return processHtml(str);
	}

	private static ArrayList<String> processHtml(String str) {

		ArrayList<String> list = new ArrayList<String>();

		// System.out.println(str);

		String line = "";
		line = getNextRow(str);

		while ((line = getNextRow(str)) != null) {
			String line2 = processColumn(line);
			line = getNextRow(str);
			// System.out.println(line2);
			String line3 = processColumn(line);
			list.add(line2 + line3);
		}

		return list;

	}

	private static String getNextRow(String str) {
		int i = str.indexOf("<tr", pos);
		// System.out.println(pos + "  " + i);
		// System.out.println(str.substring(pos));
		if (i == -1)
			return null;

		i = str.indexOf(">", i);

		int j = str.indexOf(ROW_END, i);
		// System.out.println(pos + "  " + i + "  " + j);
		pos = j;
		return str.substring(i, j);
	}

	private static String processColumn(String line) {
		int colpos = 0;
		StringBuffer sb = new StringBuffer();
		// while (true) {
		// int i = line.indexOf(COL_START, colpos);
		// if (i == -1)
		// break;
		// i = line.indexOf(">", i);
		// int j = line.indexOf(COL_END, i);
		// String value = line.substring(i + 1, j);
		// // System.out.println(value);
		// value = processValue(value.trim());
		// sb.append(value).append("	");
		// // System.out.println(value);
		// colpos = j;
		// }
		Matcher m = p.matcher(line); // get a matcher object
		while (m.find()) {
			// System.out.println("start(): " + m.start());
			// System.out.println("end(): " + m.end());
			int i = m.end() + 0;
			String s2 = line.substring(i);
			Matcher m2 = p2.matcher(s2); // get a matcher object
			int j = s2.length();
			if (m2.find()) {
				j = m2.start();
			}
			// System.out.println("------>" + i + "  " + j);
			// System.out.println("------>" + s2.substring(0,j));
			String value = s2.substring(0, j);
			value = processValue(value.trim());
			sb.append(value).append("	");
		}

		return sb.toString();
	}

	private static String processValue(String trim) {
		// trim = getValue(trim, STYLE_START, STYLE_END);
		trim = removeTag(trim, "<b ", ">");
		trim = removeTag(trim, "</b", ">");
		trim = removeTag(trim, "<a ", ">");
		trim = removeTag(trim, "</a", ">");
		trim = removeTag(trim, "<div", ">");
		trim = removeTag(trim, "</div", ">");
		return trim;
	}

	private static String removeTag(String trim, String tagStart, String tagEnd) {
		int i = trim.indexOf(tagStart);
		if (i == -1)
			return trim;

		int j = trim.indexOf(tagEnd);
		String value = trim.substring(0, i)
				+ trim.substring(j + 1, trim.length());
		return value.trim();
	}

	private static String getValue(String trim, String tagStart, String tagEnd) {
		int i = trim.indexOf(tagStart);
		if (i == -1)
			return trim;

		int j = trim.indexOf(tagEnd);
		String value = trim.substring(i + tagStart.length(), j);
		return value.trim();
	}

	private static String readFile(String file, String ban)
			throws MalformedURLException, IOException, InterruptedException {
		URL url;
		URLConnection urlConn;
		InputStream inStream;
		String urlFull = file.replaceAll(" ", "");
		
		url = new URL(urlFull);
//		System.out.println("VSN SSA " + urlFull);
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		urlConn = url.openConnection();
		inStream = urlConn.getInputStream();
		int len = 0;
		String END = "</html>";

		// System.out.println("Starting for " + urlFull);
		// Read and print the lines from index.html
		byte[] bar = new byte[1024];
		while ((len = inStream.read(bar)) > 0) {
			baos.write(bar, 0, len);
			bar = new byte[1024];
			Thread.sleep(1);
		}
		String str = new String(baos.toByteArray());
		int pos1 = str.indexOf("<html>");
		int pos2 = str.indexOf(END);
		int end = pos2 + END.length();
		// System.out.println(end);
		if (pos1 < 0)
			pos1 = 0;
		if (end > str.length() || end == -1)
			end = str.length();
		// System.out.println(pos1 + "   " + end);
		if (end < pos1) {
			// System.out.println(str);
			end = str.length();
		}
		str = str.substring(pos1, end);
		// System.out.println("Completed " + file + "  \n" + str + "\n\n\n");
		// `.println(" Read " + ban + " " + file);
		inStream.close();
		
		return str;
	}

	private static String getFileDirName(String file) {
		String val = "";
		int posEnd = file.lastIndexOf("/");
		if (posEnd > -1) {
			int posStart = file.lastIndexOf("/", posEnd - 1);
			if (posStart > -1) {
				val = file.substring(posStart + 1, posEnd);
				val = URLDecoder.decode(val);
			}
		}
		return val;
	}

}
